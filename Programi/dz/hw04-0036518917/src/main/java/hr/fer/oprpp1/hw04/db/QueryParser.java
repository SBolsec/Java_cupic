package hr.fer.oprpp1.hw04.db;

import java.util.ArrayList;
import java.util.List;

/**
 * Parses the query that the user input.
 * @author sbolsec
 *
 */
public class QueryParser {
	
	/** List of conditional expressions generated from the query **/
	private List<ConditionalExpression> list;
	/** Lexer that generates the tokens **/
	private QueryLexer lexer;
	/** List of tokens generated by lexer **/
	private List<QueryToken> tokens;
	
	public QueryParser(String statement) {
		if (statement == null)
			throw new QueryParserException("Query can not be null!");
		if (statement.isBlank())
			throw new QueryParserException("Query can not be blank!");
		
		list = new ArrayList<>();
		lexer = new QueryLexer(statement);
		tokens = new ArrayList<>();
		startParsing();
	}
	
	/**
	 * Returns true if query had only one comparison, on attribute jmbag, and operator
	 * must be equals.
	 * @return true if query had only one comparison, on attribute jmbag, and operator must be equals, false otherwise
	 */
	public boolean isDirectQuery() {
		if (list.size() != 1) return false;
		ConditionalExpression expr = list.get(0);
		if (expr.getFieldGetter() == FieldValueGetters.JMBAG &&
				expr.getComparisonOperator() == ComparisonOperators.EQUALS)
			return true;
		return false;
	}
	
	/**
	 * Returns the string which was given in equality comparison in direct query.
	 * If the query was not a direct one, method throws <code>IllegalStateException</code>
	 * @return string which was given in equality comparison in direct query
	 * @throws IllegalStateException if the query was not a direct one
	 */
	public String getQueriedJMBAG() {
		if (!isDirectQuery()) throw new IllegalStateException("The query was not a direct one!");
		return list.get(0).getStringLiteral();
	}

	/**
	 * Returns a list of conditional expressions from query.
	 * @return list of condiftional expressions from query
	 */
	public List<ConditionalExpression> getQuery() {
		return list;
	}
	
	/**
	 * Method which does the actual parsing.
	 * @throws QueryParserException if there is a error while parsing
	 */
	private void startParsing() {
		// Generate all the tokens using the lexer
		generateTokens();
		
		for (int i = 0, n = tokens.size(); i < n; i++) {
			// First token must be a field name 
			QueryToken field = tokens.get(i);
			if (field.getType() != QueryTokenType.FIELD_NAME)
				throw new QueryParserException("Query must start by field name!");
			
			// Next token must be a operator
			if (i + 1 >= n)
				throw new QueryParserException("Missing operator after field name!");
			QueryToken operator = tokens.get(++i);
			if (operator.getType() != QueryTokenType.OPERATOR)
				throw new QueryParserException("There must be a operator after a field name!");
			
			// Next token must be string literal
			if (i + 1 >= n)
				throw new QueryParserException("Missing operator after field name!");
			QueryToken literal = tokens.get(++i);
			if (literal.getType() != QueryTokenType.STRING_LITERAL)
				throw new QueryParserException("There must be a operator after a field name!");
			
			// Get type of getter
			IFieldValueGetter getter = null;
			switch (field.getValue()) {
				case "firstName": getter = FieldValueGetters.FIRST_NAME; break;
				case "lastName": getter =  FieldValueGetters.LAST_NAME; break;
				case "jmbag": getter = FieldValueGetters.JMBAG; break;
			}
			
			// Get type of comparison
			IComparisonOperator oper = null;
			switch (operator.getValue()) {
				case "<": oper = ComparisonOperators.LESS; break;
				case "<=": oper = ComparisonOperators.LESS_OR_EQUALS; break;
				case ">": oper = ComparisonOperators.GREATER; break;
				case ">=": oper = ComparisonOperators.GREATER_OR_EQUALS; break;
				case "=": oper = ComparisonOperators.EQUALS; break;
				case "!=": oper = ComparisonOperators.NOT_EQUALS; break;
				case "LIKE": oper = ComparisonOperators.LIKE; break;
			}
			
			// Add the conditional expression to the list
			ConditionalExpression expr = new ConditionalExpression(getter, literal.getValue(), oper);
			list.add(expr);
			
			// Check if there is more comparisons connected with 'and'
			if (i + 1 < n) {
				QueryToken next = tokens.get(++i);
				if (next.getType() != QueryTokenType.AND)
					throw new QueryParserException("There must be 'and' between comparisons!");
				if (i + 1 >= n)
					throw new QueryParserException("There is an useless and!");
			}
		}
	}
	
	/**
	 * Method which generates the tokens using the lexer.
	 * @throws QueryParserException if there was a error in the lexer
	 */
	private void generateTokens() {
		try {
			QueryToken token;
			while ((token = lexer.nextToken()) != null && token.getType() != QueryTokenType.EOF) {
				tokens.add(token);
			}
		} catch (QueryLexerException e) {
			throw new QueryParserException("Exception in lexer with message: " + e.getMessage());
		}
		
	}
}
